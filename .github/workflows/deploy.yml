name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      skip_visual_verification:
        description: 'Skip visual verification (emergency deploy)'
        required: false
        default: 'false'
        type: boolean

env:
  DEPLOY_PATH: /opt/expertly-develop
  SITES: "define develop identity admin manage salon today vibetest vibecode"

jobs:
  # Pre-flight check: TypeScript compilation for all frontends
  # Catches type errors in ~30s instead of waiting for Docker builds
  typecheck:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false  # Check ALL apps, don't stop on first failure
      matrix:
        app:
          - { name: admin, path: apps/admin/frontend }
          - { name: define, path: apps/define/frontend }
          - { name: develop, path: apps/develop/frontend }
          - { name: identity, path: apps/identity/frontend }
          - { name: manage, path: apps/manage/frontend }
          - { name: salon, path: apps/salon/frontend }
          - { name: today, path: apps/today/frontend }
          - { name: vibetest, path: apps/vibetest/frontend }
          - { name: vibecode, path: apps/vibecode/packages/client }
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: ${{ matrix.app.path }}/package-lock.json
      - name: Install dependencies
        working-directory: ${{ matrix.app.path }}
        run: npm ci --ignore-scripts
      - name: TypeScript check
        working-directory: ${{ matrix.app.path }}
        run: npx tsc --noEmit
        continue-on-error: false

  # Build shared infrastructure first (mongo, ui package)
  build-shared:
    needs: typecheck
    runs-on: ubuntu-latest
    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Build shared infrastructure
        run: |
          ssh -i ~/.ssh/deploy_key root@${{ secrets.SERVER_HOST }} << 'ENDSSH'
            set -e
            cd /opt/expertly-develop

            # Pull latest code
            git pull origin main

            # Initialize state file if needed
            STATE_FILE="/opt/deployment-state.json"
            if [ ! -f "$STATE_FILE" ]; then
                echo '{"active": "blue", "last_deploy": ""}' > "$STATE_FILE"
            fi

            # Get target color
            CURRENT=$(jq -r '.active' "$STATE_FILE")
            if [ "$CURRENT" = "blue" ]; then
                TARGET="green"
            else
                TARGET="blue"
            fi

            export GIT_COMMIT=$(git rev-parse --short HEAD)
            export BUILD_TIMESTAMP=$(date +%s)
            export DEPLOY_COLOR="-${TARGET}"

            echo "=== Building shared infrastructure for $TARGET ==="
            COMPOSE_PROJECT_NAME="expertly-${TARGET}" DEPLOY_COLOR="-${TARGET}" \
                docker compose -f docker-compose.prod.yml build mongo ui

            echo "=== Starting mongo ==="
            COMPOSE_PROJECT_NAME="expertly-${TARGET}" DEPLOY_COLOR="-${TARGET}" \
                docker compose -f docker-compose.prod.yml up -d mongo

            echo "=== Shared infrastructure ready ==="
          ENDSSH

  # Build each app independently - failures don't block other apps
  build:
    needs: [typecheck, build-shared]  # Build after shared infrastructure
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false  # Continue building other apps if one fails
      matrix:
        app:
          - { name: define, services: "define-frontend define-backend" }
          - { name: develop, services: "develop-frontend develop-backend" }
          - { name: identity, services: "identity-frontend identity-backend" }
          - { name: admin, services: "admin-frontend" }
          - { name: manage, services: "manage-frontend manage-backend" }
          - { name: salon, services: "salon-frontend salon-backend" }
          - { name: today, services: "today-frontend today-backend" }
          - { name: vibetest, services: "vibetest-frontend vibetest-backend" }
          - { name: vibecode, services: "vibecode-client vibecode-server" }

    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Build ${{ matrix.app.name }}
        id: build
        run: |
          ssh -i ~/.ssh/deploy_key root@${{ secrets.SERVER_HOST }} << 'ENDSSH' 2>&1 | tee build-${{ matrix.app.name }}.log
            set -e
            cd /opt/expertly-develop

            # Pull latest code (idempotent)
            git pull origin main 2>/dev/null || true

            # Initialize state file if needed
            STATE_FILE="/opt/deployment-state.json"
            if [ ! -f "$STATE_FILE" ]; then
                echo '{"active": "blue", "last_deploy": ""}' > "$STATE_FILE"
            fi

            # Get target color
            CURRENT=$(jq -r '.active' "$STATE_FILE")
            if [ "$CURRENT" = "blue" ]; then
                TARGET="green"
            else
                TARGET="blue"
            fi

            # Set build variables
            export GIT_COMMIT=$(git rev-parse --short HEAD)
            export BUILD_TIMESTAMP=$(date +%s)
            export DEPLOY_COLOR="-${TARGET}"

            echo "=== Building ${{ matrix.app.name }} for $TARGET deployment ==="
            COMPOSE_PROJECT_NAME="expertly-${TARGET}" DEPLOY_COLOR="-${TARGET}" \
                docker compose -f docker-compose.prod.yml build ${{ matrix.app.services }}

            # Mark this app as built successfully
            mkdir -p /tmp/build-results
            echo "success" > /tmp/build-results/${{ matrix.app.name }}

            echo "=== ${{ matrix.app.name }} build complete ==="
          ENDSSH

      - name: Upload build log on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: build-log-${{ matrix.app.name }}
          path: build-${{ matrix.app.name }}.log
          retention-days: 7

  # Deploy all successfully built apps
  deploy:
    needs: build
    runs-on: ubuntu-latest
    # Run even if some builds failed (we'll deploy what succeeded)
    if: always() && !cancelled()
    outputs:
      deploy_color: ${{ steps.deploy.outputs.deploy_color }}
      deployed_apps: ${{ steps.deploy.outputs.deployed_apps }}

    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Check build results and deploy
        id: deploy
        run: |
          # Get build results from server and deploy
          ssh -i ~/.ssh/deploy_key root@${{ secrets.SERVER_HOST }} << 'ENDSSH' 2>&1 | tee deploy.log
            set -e
            cd /opt/expertly-develop

            STATE_FILE="/opt/deployment-state.json"
            BUILD_RESULTS="/tmp/build-results"

            # Get target color
            CURRENT=$(jq -r '.active' "$STATE_FILE")
            if [ "$CURRENT" = "blue" ]; then
                TARGET="green"
            else
                TARGET="blue"
            fi

            echo "DEPLOY_COLOR=$TARGET" > /tmp/deploy_output
            echo "Current active: $CURRENT, deploying to: $TARGET"

            # Check which apps built successfully
            echo "=== Checking build results ==="
            SERVICES=""
            DEPLOYED_APPS=""
            SUCCESS_COUNT=0

            for app in define develop identity admin manage salon today vibetest vibecode; do
              if [ -f "$BUILD_RESULTS/$app" ] && [ "$(cat $BUILD_RESULTS/$app)" = "success" ]; then
                echo "✓ $app built successfully"
                SUCCESS_COUNT=$((SUCCESS_COUNT+1))
                DEPLOYED_APPS="$DEPLOYED_APPS $app"
                case $app in
                  define) SERVICES="$SERVICES define-frontend define-backend" ;;
                  develop) SERVICES="$SERVICES develop-frontend develop-backend" ;;
                  identity) SERVICES="$SERVICES identity-frontend identity-backend" ;;
                  admin) SERVICES="$SERVICES admin-frontend" ;;
                  manage) SERVICES="$SERVICES manage-frontend manage-backend" ;;
                  salon) SERVICES="$SERVICES salon-frontend salon-backend" ;;
                  today) SERVICES="$SERVICES today-frontend today-backend" ;;
                  vibetest) SERVICES="$SERVICES vibetest-frontend vibetest-backend" ;;
                  vibecode) SERVICES="$SERVICES vibecode-client vibecode-server" ;;
                esac
              else
                echo "✗ $app build failed or not found"
              fi
            done

            echo "DEPLOYED_APPS=$DEPLOYED_APPS" >> /tmp/deploy_output

            if [ $SUCCESS_COUNT -eq 0 ]; then
              echo "::error::All builds failed! Aborting deployment."
              exit 1
            fi

            echo ""
            echo "$SUCCESS_COUNT of 9 apps built successfully"
            echo "Services to deploy: $SERVICES"

            echo "=== Starting containers for successful builds ==="
            COMPOSE_PROJECT_NAME="expertly-${TARGET}" DEPLOY_COLOR="-${TARGET}" \
                docker compose -f docker-compose.prod.yml up -d $SERVICES

            echo "=== Waiting for containers to be ready ==="
            sleep 15

            # Health check for deployed backend services
            echo "=== Running health checks ==="
            check_container() {
              container="expertly-${TARGET}-$1-1"
              if docker ps --filter "name=$container" --filter "status=running" -q | grep -q .; then
                  echo "✓ $container is running"
                  return 0
              else
                  echo "✗ $container not running"
                  return 1
              fi
            }

            FAILED=0
            [ -f "$BUILD_RESULTS/define" ] && [ "$(cat $BUILD_RESULTS/define)" = "success" ] && { check_container "define-backend" || FAILED=1; }
            [ -f "$BUILD_RESULTS/develop" ] && [ "$(cat $BUILD_RESULTS/develop)" = "success" ] && { check_container "develop-backend" || FAILED=1; }
            [ -f "$BUILD_RESULTS/identity" ] && [ "$(cat $BUILD_RESULTS/identity)" = "success" ] && { check_container "identity-backend" || FAILED=1; }
            [ -f "$BUILD_RESULTS/manage" ] && [ "$(cat $BUILD_RESULTS/manage)" = "success" ] && { check_container "manage-backend" || FAILED=1; }
            [ -f "$BUILD_RESULTS/salon" ] && [ "$(cat $BUILD_RESULTS/salon)" = "success" ] && { check_container "salon-backend" || FAILED=1; }
            [ -f "$BUILD_RESULTS/today" ] && [ "$(cat $BUILD_RESULTS/today)" = "success" ] && { check_container "today-backend" || FAILED=1; }
            [ -f "$BUILD_RESULTS/vibetest" ] && [ "$(cat $BUILD_RESULTS/vibetest)" = "success" ] && { check_container "vibetest-backend" || FAILED=1; }
            [ -f "$BUILD_RESULTS/vibecode" ] && [ "$(cat $BUILD_RESULTS/vibecode)" = "success" ] && { check_container "vibecode-server" || FAILED=1; }

            if [ $FAILED -eq 1 ]; then
              echo "::error::Some containers failed health check"
              exit 1
            fi

            # Clean up build results for next deployment
            rm -rf "$BUILD_RESULTS"

            echo "=== Deployment complete ==="
          ENDSSH

          # Extract deploy color and deployed apps
          DEPLOY_COLOR=$(ssh -i ~/.ssh/deploy_key root@${{ secrets.SERVER_HOST }} "grep DEPLOY_COLOR /tmp/deploy_output | cut -d= -f2" || echo "green")
          DEPLOYED_APPS=$(ssh -i ~/.ssh/deploy_key root@${{ secrets.SERVER_HOST }} "grep DEPLOYED_APPS /tmp/deploy_output | cut -d= -f2" || echo "")
          echo "deploy_color=${DEPLOY_COLOR}" >> $GITHUB_OUTPUT
          echo "deployed_apps=${DEPLOYED_APPS}" >> $GITHUB_OUTPUT

      - name: Upload deploy log on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: deploy-logs
          path: deploy.log
          retention-days: 7

  visual-verification:
    needs: deploy
    runs-on: ubuntu-latest
    if: always() && !cancelled() && needs.deploy.result == 'success' && github.event.inputs.skip_visual_verification != 'true'

    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Playwright
        run: |
          npm init -y
          npm install playwright
          npx playwright install chromium

      - name: Take screenshots and verify
        id: visual
        env:
          DEPLOYED_APPS: ${{ needs.deploy.outputs.deployed_apps }}
        run: |
          mkdir -p screenshots

          FAILED=0
          VERIFIED=0
          SKIPPED=0

          verify_site() {
            site=$1
            echo "Checking $site..."

            # Take screenshot
            npx playwright screenshot --wait-for-timeout=5000 \
              "https://${site}.ai.devintensive.com" \
              "screenshots/${site}.png" 2>/dev/null || true

            # Check if screenshot exists and has content (not blank)
            if [ -f "screenshots/${site}.png" ]; then
              # Get file size - blank pages are usually very small
              SIZE=$(stat -f%z "screenshots/${site}.png" 2>/dev/null || stat -c%s "screenshots/${site}.png" 2>/dev/null)
              if [ "$SIZE" -gt 10000 ]; then
                echo "✓ $site - screenshot captured (${SIZE} bytes)"
                return 0
              else
                echo "⚠ $site - screenshot too small, may be blank (${SIZE} bytes)"
                return 1
              fi
            else
              echo "✗ $site - failed to capture screenshot"
              return 1
            fi
          }

          echo "Deployed apps: $DEPLOYED_APPS"
          echo ""

          # Verify all apps, marking skipped ones
          for app in define develop identity admin manage salon today vibetest vibecode; do
            if echo "$DEPLOYED_APPS" | grep -qw "$app"; then
              verify_site "$app" && VERIFIED=$((VERIFIED+1)) || FAILED=1
            else
              echo "⊘ $app - skipped (not deployed)"
              SKIPPED=$((SKIPPED+1))
            fi
          done

          echo ""
          echo "Summary: $VERIFIED verified, $SKIPPED skipped (not deployed)"
          echo "verification_failed=$FAILED" >> $GITHUB_OUTPUT

      - name: Upload screenshots
        uses: actions/upload-artifact@v4
        with:
          name: visual-verification-screenshots
          path: screenshots/
          retention-days: 7

      - name: Fail if verification failed
        if: steps.visual.outputs.verification_failed == '1'
        run: |
          echo "Visual verification failed for deployed apps! Check screenshots artifact."
          exit 1

  switch-traffic:
    needs: [deploy, visual-verification]
    runs-on: ubuntu-latest
    # Only switch if deploy succeeded (visual-verification may be skipped)
    if: always() && needs.deploy.result == 'success'

    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Switch traffic to new deployment
        run: |
          ssh -i ~/.ssh/deploy_key root@${{ secrets.SERVER_HOST }} << 'ENDSSH'
            set -e

            STATE_FILE="/opt/deployment-state.json"
            TRAEFIK_DYNAMIC="/opt/traefik/dynamic"

            # Get target color (the one we just deployed to)
            CURRENT=$(jq -r '.active' "$STATE_FILE")
            if [ "$CURRENT" = "blue" ]; then
                TARGET="green"
                OLD="blue"
            else
                TARGET="blue"
                OLD="green"
            fi

            echo "=== Switching traffic from $OLD to $TARGET ==="

            # Update Traefik routing to point to new containers
            # Since we're using Docker provider with labels, containers are auto-discovered
            # We just need to stop the old containers

            # Update state file
            jq --arg color "$TARGET" --arg time "$(date -Iseconds)" \
                '.active = $color | .last_deploy = $time' "$STATE_FILE" > "${STATE_FILE}.tmp"
            mv "${STATE_FILE}.tmp" "$STATE_FILE"

            echo "=== Waiting for traffic to drain from old deployment ==="
            sleep 10

            echo "=== Stopping old $OLD deployment ==="
            cd /opt/expertly-develop
            COMPOSE_PROJECT_NAME="expertly-${OLD}" DEPLOY_COLOR="-${OLD}" \
                docker compose -f docker-compose.prod.yml down --remove-orphans || true

            # Also stop legacy containers if this is migration from old naming
            if docker ps --filter "name=expertly-develop-" -q | grep -q .; then
                echo "=== Stopping legacy expertly-develop containers (migration) ==="
                docker compose -f docker-compose.prod.yml down --remove-orphans || true
            fi

            echo "=== Cleaning up old images ==="
            docker image prune -f

            echo "=== Blue/green deployment complete ==="
            echo "Active: $TARGET"
          ENDSSH

      - name: Final verification
        env:
          DEPLOYED_APPS: ${{ needs.deploy.outputs.deployed_apps }}
        run: |
          echo "Verifying deployed sites respond..."
          echo "Deployed apps: $DEPLOYED_APPS"
          sleep 5

          # Check all deployed apps
          for app in $DEPLOYED_APPS; do
            status=$(curl -s -o /dev/null -w "%{http_code}" "https://${app}.ai.devintensive.com/" || echo "000")
            echo "${app}: HTTP ${status}"
          done

  rollback-on-failure:
    needs: [deploy, visual-verification]
    runs-on: ubuntu-latest
    # Only rollback if deploy failed (not if just some builds failed)
    if: always() && needs.deploy.result == 'failure'

    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Rollback - stop failed deployment
        run: |
          ssh -i ~/.ssh/deploy_key root@${{ secrets.SERVER_HOST }} << 'ENDSSH'
            set -e

            STATE_FILE="/opt/deployment-state.json"

            # Get the color we deployed to (which failed)
            CURRENT=$(jq -r '.active' "$STATE_FILE")
            if [ "$CURRENT" = "blue" ]; then
                FAILED="green"
            else
                FAILED="blue"
            fi

            echo "=== Rolling back - stopping failed $FAILED deployment ==="
            cd /opt/expertly-develop

            COMPOSE_PROJECT_NAME="expertly-${FAILED}" DEPLOY_COLOR="-${FAILED}" \
                docker compose -f docker-compose.prod.yml down --remove-orphans || true

            echo "=== Rollback complete - $CURRENT still active ==="
          ENDSSH
