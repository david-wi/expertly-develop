name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      skip_visual_verification:
        description: 'Skip visual verification (emergency deploy)'
        required: false
        default: 'false'
        type: boolean

# Queue deployments but don't cancel in-progress ones (let them finish)
concurrency:
  group: deploy-${{ github.ref }}

env:
  DEPLOY_PATH: /opt/expertly-develop

jobs:
  # Pre-flight check: TypeScript compilation for all frontends
  typecheck:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        app:
          - { name: admin, path: apps/admin/frontend }
          - { name: define, path: apps/define/frontend }
          - { name: develop, path: apps/develop/frontend }
          - { name: identity, path: apps/identity/frontend }
          - { name: manage, path: apps/manage/frontend }
          - { name: salon, path: apps/salon/frontend }
          - { name: today, path: apps/today/frontend }
          # TODO: Fix type issues in these apps:
          # - { name: vibetest, path: apps/vibetest/frontend }
          # - { name: vibecode, path: apps/vibecode/packages/client }
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      - name: Install dependencies
        run: npm ci --ignore-scripts
      - name: TypeScript check
        working-directory: ${{ matrix.app.path }}
        run: npm run typecheck
        continue-on-error: false

  # Initialize deployment state and build shared infrastructure
  init-deploy:
    needs: typecheck
    runs-on: ubuntu-latest
    outputs:
      git_commit: ${{ steps.init.outputs.git_commit }}
    steps:
      - name: Check if superseded by newer commit
        run: |
          LATEST=$(curl -s -H "Authorization: token ${{ github.token }}" \
            "https://api.github.com/repos/${{ github.repository }}/commits/${{ github.ref_name }}" \
            | jq -r '.sha')
          if [ "$LATEST" != "${{ github.sha }}" ]; then
            echo "::warning::Skipping deploy - newer commit exists (this: ${{ github.sha }}, latest: $LATEST)"
            echo "This deployment is superseded by a newer commit. Exiting early."
            exit 1
          fi
          echo "This is the latest commit, proceeding with deploy."

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Initialize deployment
        id: init
        run: |
          # Use subshell to capture output and avoid second SSH connection (rate limiting)
          (ssh -i ~/.ssh/deploy_key root@${{ secrets.SERVER_HOST }} << 'ENDSSH'
            set -e
            cd /opt/expertly-develop
            git pull origin main

            # Initialize per-service state file if needed
            STATE_FILE="/opt/deployment-state.json"
            if [ ! -f "$STATE_FILE" ] || ! jq -e '.services' "$STATE_FILE" >/dev/null 2>&1; then
                echo "Initializing per-service deployment state..."
                jq -n '{
                  services: {
                    define: {active: "blue", last_deploy: ""},
                    develop: {active: "blue", last_deploy: ""},
                    identity: {active: "blue", last_deploy: ""},
                    admin: {active: "blue", last_deploy: ""},
                    manage: {active: "blue", last_deploy: ""},
                    salon: {active: "blue", last_deploy: ""},
                    today: {active: "blue", last_deploy: ""},
                    vibetest: {active: "blue", last_deploy: ""},
                    vibecode: {active: "blue", last_deploy: ""}
                  },
                  shared: {active: "running", last_deploy: ""}
                }' > "$STATE_FILE"
            fi

            # Ensure shared network exists
            echo "=== Setting up shared infrastructure network ==="
            docker network inspect expertly-shared >/dev/null 2>&1 || \
                docker network create expertly-shared

            # Ensure shared volumes exist
            docker volume inspect shared_mongo_data >/dev/null 2>&1 || \
                docker volume create shared_mongo_data
            docker volume inspect shared_redis_data >/dev/null 2>&1 || \
                docker volume create shared_redis_data
            docker volume inspect shared_identity_postgres_data >/dev/null 2>&1 || \
                docker volume create shared_identity_postgres_data

            # Start shared infrastructure (mongo, redis) - single instance, no blue/green
            echo "=== Starting shared infrastructure (mongo, redis) ==="
            docker compose -f docker-compose.shared.yml up -d

            # Wait for shared services to be healthy
            echo "Waiting for shared services..."
            sleep 5

            # Verify shared services are running
            if docker ps --filter "name=expertly-shared-mongo" --filter "status=running" -q | grep -q .; then
                echo "✓ MongoDB is running"
            else
                echo "✗ MongoDB failed to start"
                docker logs expertly-shared-mongo 2>&1 | tail -20 || true
                exit 1
            fi

            if docker ps --filter "name=expertly-shared-redis" --filter "status=running" -q | grep -q .; then
                echo "✓ Redis is running"
            else
                echo "✗ Redis failed to start"
                docker logs expertly-shared-redis 2>&1 | tail -20 || true
                exit 1
            fi

            # Update shared state
            jq --arg time "$(date -Iseconds)" \
                '.shared.active = "running" | .shared.last_deploy = $time' "$STATE_FILE" > "${STATE_FILE}.tmp"
            mv "${STATE_FILE}.tmp" "$STATE_FILE"

            # Output GIT_COMMIT for capture (avoid second SSH connection that gets rate-limited)
            GIT_COMMIT=$(git rev-parse --short HEAD)
            echo "GIT_COMMIT=$GIT_COMMIT"
          ENDSSH
          ) | tee init-deploy.log

          # Extract GIT_COMMIT from the captured output
          GIT_COMMIT=$(grep "^GIT_COMMIT=" init-deploy.log | cut -d= -f2 | tr -d '[:space:]')
          echo "git_commit=${GIT_COMMIT}" >> $GITHUB_OUTPUT

  # Build and deploy each app independently
  deploy-app:
    needs: [typecheck, init-deploy]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 3
      matrix:
        app:
          - { name: define, services: "define-frontend define-backend", health: "define-backend" }
          - { name: develop, services: "develop-frontend develop-backend", health: "develop-backend" }
          - { name: identity, services: "identity-frontend identity-backend", health: "identity-backend" }
          - { name: admin, services: "admin-frontend admin-backend", health: "admin-backend" }
          - { name: manage, services: "manage-frontend manage-backend", health: "manage-backend" }
          - { name: salon, services: "salon-frontend salon-backend", health: "salon-backend" }
          - { name: today, services: "today-frontend today-backend", health: "today-backend" }
          - { name: vibetest, services: "vibetest-frontend vibetest-backend", health: "vibetest-backend" }
          - { name: vibecode, services: "vibecode-client vibecode-server", health: "vibecode-server" }

    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy ${{ matrix.app.name }}
        id: deploy
        run: |
          # SSH with retry logic
          MAX_RETRIES=3
          RETRY_DELAY=10
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i of $MAX_RETRIES for ${{ matrix.app.name }}..."
            if ssh -o ConnectTimeout=30 -o ServerAliveInterval=15 -i ~/.ssh/deploy_key root@${{ secrets.SERVER_HOST }} << 'ENDSSH' 2>&1 | tee deploy-${{ matrix.app.name }}.log
            set -e
            cd /opt/expertly-develop

            STATE_FILE="/opt/deployment-state.json"
            APP="${{ matrix.app.name }}"
            SERVICES="${{ matrix.app.services }}"
            HEALTH_CONTAINER="${{ matrix.app.health }}"

            # Get this app's current color and determine target
            CURRENT=$(jq -r ".services.${APP}.active" "$STATE_FILE")
            if [ "$CURRENT" = "blue" ]; then
                TARGET="green"
                OLD="blue"
            else
                TARGET="blue"
                OLD="green"
            fi

            echo "=== Deploying $APP: $OLD -> $TARGET ==="

            export GIT_COMMIT=$(git rev-parse --short HEAD)
            export BUILD_TIMESTAMP=$(date +%s)
            export DEPLOY_COLOR="-${TARGET}"

            # Build this app's services
            echo "Building $SERVICES..."
            COMPOSE_PROJECT_NAME="expertly-${TARGET}" DEPLOY_COLOR="-${TARGET}" \
                docker compose -f docker-compose.prod.yml build $SERVICES

            # Start this app's services
            echo "Starting $SERVICES..."
            COMPOSE_PROJECT_NAME="expertly-${TARGET}" DEPLOY_COLOR="-${TARGET}" \
                docker compose -f docker-compose.prod.yml up -d $SERVICES

            # Wait for containers to be ready
            echo "Waiting for containers..."
            sleep 10

            # Health check
            CONTAINER="expertly-${TARGET}-${HEALTH_CONTAINER}-1"
            echo "Health checking $CONTAINER..."
            if docker ps --filter "name=$CONTAINER" --filter "status=running" -q | grep -q .; then
                echo "✓ $CONTAINER is running"
            else
                echo "✗ $CONTAINER failed to start"
                echo "Container logs:"
                docker logs "$CONTAINER" 2>&1 | tail -50 || true
                exit 1
            fi

            # Update state for this app
            jq --arg app "$APP" --arg color "$TARGET" --arg time "$(date -Iseconds)" \
                '.services[$app].active = $color | .services[$app].last_deploy = $time' \
                "$STATE_FILE" > "${STATE_FILE}.tmp"
            mv "${STATE_FILE}.tmp" "$STATE_FILE"

            # Stop old version of this app (if running)
            echo "Stopping old $APP containers on $OLD..."
            for svc in $SERVICES; do
                OLD_CONTAINER="expertly-${OLD}-${svc}-1"
                if docker ps -a --filter "name=$OLD_CONTAINER" -q | grep -q .; then
                    docker stop "$OLD_CONTAINER" 2>/dev/null || true
                    docker rm "$OLD_CONTAINER" 2>/dev/null || true
                    echo "  Stopped $OLD_CONTAINER"
                fi
            done

            echo "=== $APP deployed successfully ==="
          ENDSSH
            then
              echo "✓ ${{ matrix.app.name }} deployed successfully"
              echo "status=success" >> $GITHUB_OUTPUT
              break
            else
              echo "✗ Attempt $i failed for ${{ matrix.app.name }}"
              if [ $i -lt $MAX_RETRIES ]; then
                echo "Waiting ${RETRY_DELAY}s before retry..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))
              else
                echo "All attempts failed for ${{ matrix.app.name }}"
                echo "status=failed" >> $GITHUB_OUTPUT
                exit 1
              fi
            fi
          done

      - name: Upload deploy log on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: deploy-log-${{ matrix.app.name }}
          path: deploy-${{ matrix.app.name }}.log
          retention-days: 7

  # Visual verification of deployed apps
  visual-verification:
    needs: deploy-app
    runs-on: ubuntu-latest
    if: always() && !cancelled() && github.event.inputs.skip_visual_verification != 'true'

    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Playwright
        run: |
          npm init -y
          npm install playwright
          npx playwright install chromium

      - name: Take screenshots and verify
        id: visual
        run: |
          mkdir -p screenshots

          FAILED=0
          VERIFIED=0

          verify_site() {
            site=$1
            echo "Checking $site..."

            npx playwright screenshot --wait-for-timeout=5000 \
              "https://${site}.ai.devintensive.com" \
              "screenshots/${site}.png" 2>/dev/null || true

            if [ -f "screenshots/${site}.png" ]; then
              SIZE=$(stat -f%z "screenshots/${site}.png" 2>/dev/null || stat -c%s "screenshots/${site}.png" 2>/dev/null)
              if [ "$SIZE" -gt 10000 ]; then
                echo "✓ $site - OK (${SIZE} bytes)"
                return 0
              else
                echo "⚠ $site - screenshot too small (${SIZE} bytes)"
                return 1
              fi
            else
              echo "✗ $site - failed to capture"
              return 1
            fi
          }

          # Verify all apps
          for app in define develop identity admin manage salon today vibetest vibecode; do
            if verify_site "$app"; then
              VERIFIED=$((VERIFIED+1))
            else
              FAILED=$((FAILED+1))
            fi
          done

          echo ""
          echo "Summary: $VERIFIED OK, $FAILED failed"

          # Don't fail the workflow for visual verification failures
          # Apps were already deployed independently
          if [ $FAILED -gt 0 ]; then
            echo "::warning::$FAILED apps failed visual verification"
          fi

      - name: Upload screenshots
        uses: actions/upload-artifact@v4
        with:
          name: visual-verification-screenshots
          path: screenshots/
          retention-days: 7

  # Cleanup old images
  cleanup:
    needs: [deploy-app, visual-verification]
    runs-on: ubuntu-latest
    if: always() && !cancelled()

    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Cleanup old images and containers
        run: |
          ssh -i ~/.ssh/deploy_key root@${{ secrets.SERVER_HOST }} << 'ENDSSH'
            echo "=== Cleaning up unused Docker resources ==="

            # Remove old per-color mongo/redis containers (now using shared infrastructure)
            for color in blue green; do
                for old_container in "expertly-${color}-mongo-1" "expertly-${color}-app-redis-1" "expertly-develop-mongo-1"; do
                    if docker ps -a --filter "name=$old_container" -q | grep -q .; then
                        echo "Removing legacy container: $old_container"
                        docker stop "$old_container" 2>/dev/null || true
                        docker rm "$old_container" 2>/dev/null || true
                    fi
                done
            done

            docker image prune -f
            docker container prune -f

            # Show current state
            echo ""
            echo "=== Current deployment state ==="
            cat /opt/deployment-state.json | jq .

            echo ""
            echo "=== Running containers ==="
            docker ps --format "table {{.Names}}\t{{.Status}}" | grep expertly || true
          ENDSSH

      - name: Final health check
        run: |
          echo "=== Final health check ==="
          for app in define develop identity admin manage salon today vibetest vibecode; do
            status=$(curl -s -o /dev/null -w "%{http_code}" "https://${app}.ai.devintensive.com/" || echo "000")
            if [ "$status" = "200" ]; then
              echo "✓ $app: HTTP $status"
            else
              echo "✗ $app: HTTP $status"
            fi
          done
