name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      skip_visual_verification:
        description: 'Skip visual verification (emergency deploy)'
        required: false
        default: 'false'
        type: boolean
      deploy_all:
        description: 'Deploy all apps (override change detection)'
        required: false
        default: 'false'
        type: boolean

# Queue deployments but don't cancel in-progress ones (let them finish)
concurrency:
  group: deploy-${{ github.ref }}

env:
  DEPLOY_PATH: /opt/expertly-develop

jobs:
  # Detect which apps have changed to enable selective deployment
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      apps_to_deploy: ${{ steps.detect.outputs.apps_to_deploy }}
      should_deploy: ${{ steps.detect.outputs.should_deploy }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need at least 2 commits to compare

      - name: Detect changed files
        id: detect
        run: |
          # If workflow_dispatch with deploy_all, or if this is a forced deployment
          if [ "${{ github.event.inputs.deploy_all }}" = "true" ] || [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "Manual dispatch - deploying all apps"
            APPS='["define","develop","identity","admin","command","salon","today","vibetest","vibecode","tms","discover","hear","cowork","aipocalypse","intake"]'
            echo "apps_to_deploy=$APPS" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Get changed files between HEAD and HEAD~1
          # Handle case where HEAD~1 doesn't exist (first commit)
          if git rev-parse HEAD~1 >/dev/null 2>&1; then
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
          else
            echo "First commit - deploying all apps"
            APPS='["define","develop","identity","admin","command","salon","today","vibetest","vibecode","tms","discover","hear","cowork","aipocalypse","intake"]'
            echo "apps_to_deploy=$APPS" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Changed files:"
          echo "$CHANGED_FILES"
          echo ""

          # Check for infrastructure changes that require full deployment
          DEPLOY_ALL=false
          if echo "$CHANGED_FILES" | grep -qE '^(docker-compose.*\.yml|package\.json|package-lock\.json|\.github/workflows/deploy\.yml)$'; then
            echo "Infrastructure files changed - deploying all apps"
            DEPLOY_ALL=true
          fi

          # Check for shared package changes
          if echo "$CHANGED_FILES" | grep -q '^packages/ui/'; then
            echo "Shared UI package changed - deploying all apps"
            DEPLOY_ALL=true
          fi

          if [ "$DEPLOY_ALL" = "true" ]; then
            APPS='["define","develop","identity","admin","command","salon","today","vibetest","vibecode","tms","discover","hear","cowork","aipocalypse","intake"]'
            echo "apps_to_deploy=$APPS" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check if only docs/non-deployment files changed
          DEPLOY_FILES=$(echo "$CHANGED_FILES" | grep -vE '^(README\.md|CLAUDE\.md|docs/|scripts/|\.claude/)' || true)
          if [ -z "$DEPLOY_FILES" ]; then
            echo "Only documentation/non-deployment files changed - skipping deployment"
            echo "apps_to_deploy=[]" >> $GITHUB_OUTPUT
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Detect which specific apps changed
          APPS_TO_DEPLOY=()

          for app in admin define develop identity command salon today vibetest vibecode tms discover hear cowork aipocalypse intake; do
            if echo "$CHANGED_FILES" | grep -q "^apps/${app}/"; then
              APPS_TO_DEPLOY+=("$app")
            fi
          done

          # Convert bash array to JSON
          if [ ${#APPS_TO_DEPLOY[@]} -eq 0 ]; then
            APPS_JSON="[]"
          else
            APPS_JSON=$(printf '%s\n' "${APPS_TO_DEPLOY[@]}" | jq -R . | jq -s -c .)
          fi

          echo "Apps to deploy: $APPS_JSON"

          echo "apps_to_deploy=$APPS_JSON" >> $GITHUB_OUTPUT

          if [ "$APPS_JSON" = "[]" ]; then
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          else
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          fi

  # Initialize deployment state and build shared infrastructure
  # Note: Typecheck is enforced by CI on PRs before merge, so not needed here
  init-deploy:
    needs: detect-changes
    if: needs.detect-changes.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    outputs:
      git_commit: ${{ steps.init.outputs.git_commit }}
    steps:
      - name: Check if superseded by newer commit
        run: |
          LATEST=$(curl -s -H "Authorization: token ${{ github.token }}" \
            "https://api.github.com/repos/${{ github.repository }}/commits/${{ github.ref_name }}" \
            | jq -r '.sha')
          if [ "$LATEST" != "${{ github.sha }}" ]; then
            echo "::warning::Skipping deploy - newer commit exists (this: ${{ github.sha }}, latest: $LATEST)"
            echo "This deployment is superseded by a newer commit. Exiting early."
            exit 1
          fi
          echo "This is the latest commit, proceeding with deploy."

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Initialize deployment
        id: init
        run: |
          # Use subshell to capture output and avoid second SSH connection (rate limiting)
          (ssh -i ~/.ssh/deploy_key root@${{ secrets.SERVER_HOST }} << 'ENDSSH'
            set -e
            cd /opt/expertly-develop
            git pull origin main

            # Generate commits.json for changelog pages
            echo "=== Generating commits.json for each app ==="
            node scripts/generate-commits.js

            # Initialize per-service state file if needed
            STATE_FILE="/opt/deployment-state.json"
            if [ ! -f "$STATE_FILE" ] || ! jq -e '.services' "$STATE_FILE" >/dev/null 2>&1; then
                echo "Initializing per-service deployment state..."
                jq -n '{
                  services: {
                    define: {active: "blue", last_deploy: ""},
                    develop: {active: "blue", last_deploy: ""},
                    identity: {active: "blue", last_deploy: ""},
                    admin: {active: "blue", last_deploy: ""},
                    command: {active: "blue", last_deploy: ""},
                    salon: {active: "blue", last_deploy: ""},
                    today: {active: "blue", last_deploy: ""},
                    vibetest: {active: "blue", last_deploy: ""},
                    vibecode: {active: "blue", last_deploy: ""},
                    tms: {active: "blue", last_deploy: ""},
                    discover: {active: "blue", last_deploy: ""},
                    hear: {active: "blue", last_deploy: ""},
                    cowork: {active: "blue", last_deploy: ""},
                    aipocalypse: {active: "blue", last_deploy: ""},
                    intake: {active: "blue", last_deploy: ""}
                  },
                  shared: {active: "running", last_deploy: ""}
                }' > "$STATE_FILE"
            fi

            # Ensure shared network exists
            echo "=== Setting up shared infrastructure network ==="
            docker network inspect expertly-shared >/dev/null 2>&1 || \
                docker network create expertly-shared

            # Ensure shared volumes exist
            docker volume inspect shared_mongo_data >/dev/null 2>&1 || \
                docker volume create shared_mongo_data
            docker volume inspect shared_redis_data >/dev/null 2>&1 || \
                docker volume create shared_redis_data
            docker volume inspect shared_identity_postgres_data >/dev/null 2>&1 || \
                docker volume create shared_identity_postgres_data

            # Start shared infrastructure (mongo, redis) - single instance, no blue/green
            echo "=== Starting shared infrastructure (mongo, redis) ==="
            docker compose -f docker-compose.shared.yml up -d

            # Wait for shared services to be healthy
            echo "Waiting for shared services..."
            sleep 5

            # Verify shared services are running
            if docker ps --filter "name=expertly-shared-mongo" --filter "status=running" -q | grep -q .; then
                echo "✓ MongoDB is running"
            else
                echo "✗ MongoDB failed to start"
                docker logs expertly-shared-mongo 2>&1 | tail -20 || true
                exit 1
            fi

            if docker ps --filter "name=expertly-shared-redis" --filter "status=running" -q | grep -q .; then
                echo "✓ Redis is running"
            else
                echo "✗ Redis failed to start"
                docker logs expertly-shared-redis 2>&1 | tail -20 || true
                exit 1
            fi

            # Update shared state
            jq --arg time "$(date -Iseconds)" \
                '.shared.active = "running" | .shared.last_deploy = $time' "$STATE_FILE" > "${STATE_FILE}.tmp"
            mv "${STATE_FILE}.tmp" "$STATE_FILE"

            # Output GIT_COMMIT for capture (avoid second SSH connection that gets rate-limited)
            GIT_COMMIT=$(git rev-parse --short HEAD)
            echo "GIT_COMMIT=$GIT_COMMIT"
          ENDSSH
          ) | tee init-deploy.log

          # Extract GIT_COMMIT from the captured output
          GIT_COMMIT=$(grep "^GIT_COMMIT=" init-deploy.log | cut -d= -f2 | tr -d '[:space:]')
          echo "git_commit=${GIT_COMMIT}" >> $GITHUB_OUTPUT

  # Build and deploy each changed app independently
  deploy-app:
    needs: [detect-changes, init-deploy]
    if: |
      needs.detect-changes.outputs.apps_to_deploy != '[]' &&
      needs.init-deploy.result == 'success'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 3
      matrix:
        app: ${{ fromJson(needs.detect-changes.outputs.apps_to_deploy) }}

    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy ${{ matrix.app }}
        id: deploy
        run: |
          # Map app name to services and health container
          case "${{ matrix.app }}" in
            define)   SERVICES="define-frontend define-backend"; HEALTH_CONTAINER="define-backend" ;;
            develop)  SERVICES="develop-frontend develop-backend"; HEALTH_CONTAINER="develop-backend" ;;
            identity) SERVICES="identity-frontend identity-backend"; HEALTH_CONTAINER="identity-backend" ;;
            admin)    SERVICES="admin-frontend admin-backend"; HEALTH_CONTAINER="admin-backend" ;;
            command)  SERVICES="command-frontend command-backend"; HEALTH_CONTAINER="command-backend" ;;
            salon)    SERVICES="salon-frontend salon-backend"; HEALTH_CONTAINER="salon-backend" ;;
            today)    SERVICES="today-frontend today-backend"; HEALTH_CONTAINER="today-backend" ;;
            vibetest) SERVICES="vibetest-frontend vibetest-backend"; HEALTH_CONTAINER="vibetest-backend" ;;
            vibecode) SERVICES="vibecode-client vibecode-server"; HEALTH_CONTAINER="vibecode-server" ;;
            tms)      SERVICES="tms-frontend tms-backend"; HEALTH_CONTAINER="tms-backend" ;;
            discover) SERVICES="discover-frontend"; HEALTH_CONTAINER="discover-frontend" ;;
            hear)     SERVICES="hear-frontend"; HEALTH_CONTAINER="hear-frontend" ;;
            cowork)   SERVICES="cowork-frontend"; HEALTH_CONTAINER="cowork-frontend" ;;
            aipocalypse) SERVICES="aipocalypse-frontend aipocalypse-backend"; HEALTH_CONTAINER="aipocalypse-backend" ;;
            intake)   SERVICES="intake-frontend intake-backend"; HEALTH_CONTAINER="intake-backend" ;;
            *)        echo "Unknown app: ${{ matrix.app }}"; exit 1 ;;
          esac

          # SSH with retry logic
          MAX_RETRIES=3
          RETRY_DELAY=10
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i of $MAX_RETRIES for ${{ matrix.app }}..."
            if ssh -o ConnectTimeout=30 -o ServerAliveInterval=15 -i ~/.ssh/deploy_key root@${{ secrets.SERVER_HOST }} << ENDSSH 2>&1 | tee deploy-${{ matrix.app }}.log
            set -e
            cd /opt/expertly-develop

            STATE_FILE="/opt/deployment-state.json"
            APP="${{ matrix.app }}"
            SERVICES="$SERVICES"
            HEALTH_CONTAINER="$HEALTH_CONTAINER"

            # Get this app's current color and determine target
            CURRENT=\$(jq -r ".services.\${APP}.active" "\$STATE_FILE")
            if [ "\$CURRENT" = "blue" ]; then
                TARGET="green"
                OLD="blue"
            else
                TARGET="blue"
                OLD="green"
            fi

            echo "=== Deploying \$APP: \$OLD -> \$TARGET ==="

            export GIT_COMMIT=\$(git rev-parse --short HEAD)
            export BUILD_TIMESTAMP=\$(date +%s)
            export DEPLOY_COLOR="-\${TARGET}"

            # Build this app's services
            echo "Building \$SERVICES..."
            COMPOSE_PROJECT_NAME="expertly-\${TARGET}" DEPLOY_COLOR="-\${TARGET}" \
                docker compose -f docker-compose.prod.yml build \$SERVICES

            # Start this app's services
            echo "Starting \$SERVICES..."
            COMPOSE_PROJECT_NAME="expertly-\${TARGET}" DEPLOY_COLOR="-\${TARGET}" \
                docker compose -f docker-compose.prod.yml up -d \$SERVICES

            # Wait for containers to be ready
            echo "Waiting for containers..."
            sleep 10

            # Health check
            CONTAINER="expertly-\${TARGET}-\${HEALTH_CONTAINER}-1"
            echo "Health checking \$CONTAINER..."
            if docker ps --filter "name=\$CONTAINER" --filter "status=running" -q | grep -q .; then
                echo "✓ \$CONTAINER is running"
            else
                echo "✗ \$CONTAINER failed to start"
                echo "Container logs:"
                docker logs "\$CONTAINER" 2>&1 | tail -50 || true
                exit 1
            fi

            # Update state for this app
            jq --arg app "\$APP" --arg color "\$TARGET" --arg time "\$(date -Iseconds)" \
                '.services[\$app].active = \$color | .services[\$app].last_deploy = \$time' \
                "\$STATE_FILE" > "\${STATE_FILE}.tmp"
            mv "\${STATE_FILE}.tmp" "\$STATE_FILE"

            # Stop old version of this app (if running)
            echo "Stopping old \$APP containers on \$OLD..."
            for svc in \$SERVICES; do
                OLD_CONTAINER="expertly-\${OLD}-\${svc}-1"
                if docker ps -a --filter "name=\$OLD_CONTAINER" -q | grep -q .; then
                    docker stop "\$OLD_CONTAINER" 2>/dev/null || true
                    docker rm "\$OLD_CONTAINER" 2>/dev/null || true
                    echo "  Stopped \$OLD_CONTAINER"
                fi
            done

            echo "=== \$APP deployed successfully ==="
          ENDSSH
            then
              echo "✓ ${{ matrix.app }} deployed successfully"
              echo "status=success" >> $GITHUB_OUTPUT
              break
            else
              echo "✗ Attempt $i failed for ${{ matrix.app }}"
              if [ $i -lt $MAX_RETRIES ]; then
                echo "Waiting ${RETRY_DELAY}s before retry..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))
              else
                echo "All attempts failed for ${{ matrix.app }}"
                echo "status=failed" >> $GITHUB_OUTPUT
                exit 1
              fi
            fi
          done

      - name: Upload deploy log on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: deploy-log-${{ matrix.app }}
          path: deploy-${{ matrix.app }}.log
          retention-days: 7

  # Visual verification of deployed apps
  visual-verification:
    needs: [detect-changes, deploy-app]
    runs-on: ubuntu-latest
    if: |
      always() &&
      !cancelled() &&
      needs.deploy-app.result == 'success' &&
      github.event.inputs.skip_visual_verification != 'true'

    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Playwright
        run: |
          npm init -y
          npm install playwright
          npx playwright install chromium

      - name: Take screenshots and verify
        id: visual
        env:
          APPS_TO_VERIFY: ${{ needs.detect-changes.outputs.apps_to_deploy }}
        run: |
          mkdir -p screenshots

          FAILED=0
          VERIFIED=0

          verify_site() {
            site=$1
            echo "Checking $site..."

            npx playwright screenshot --wait-for-timeout=5000 \
              "https://${site}.ai.devintensive.com" \
              "screenshots/${site}.png" 2>/dev/null || true

            if [ -f "screenshots/${site}.png" ]; then
              SIZE=$(stat -f%z "screenshots/${site}.png" 2>/dev/null || stat -c%s "screenshots/${site}.png" 2>/dev/null)
              if [ "$SIZE" -gt 10000 ]; then
                echo "✓ $site - OK (${SIZE} bytes)"
                return 0
              else
                echo "⚠ $site - screenshot too small (${SIZE} bytes)"
                return 1
              fi
            else
              echo "✗ $site - failed to capture"
              return 1
            fi
          }

          # Parse the apps to verify from JSON array
          APPS=$(echo "$APPS_TO_VERIFY" | jq -r '.[]' 2>/dev/null || echo "")

          if [ -z "$APPS" ]; then
            echo "No apps to verify"
            exit 0
          fi

          # Verify only the deployed apps
          for app in $APPS; do
            if verify_site "$app"; then
              VERIFIED=$((VERIFIED+1))
            else
              FAILED=$((FAILED+1))
            fi
          done

          echo ""
          echo "Summary: $VERIFIED OK, $FAILED failed"

          # Don't fail the workflow for visual verification failures
          # Apps were already deployed independently
          if [ $FAILED -gt 0 ]; then
            echo "::warning::$FAILED apps failed visual verification"
          fi

      - name: Upload screenshots
        uses: actions/upload-artifact@v4
        with:
          name: visual-verification-screenshots
          path: screenshots/
          retention-days: 7

  # Cleanup old images
  cleanup:
    needs: [detect-changes, deploy-app, visual-verification]
    runs-on: ubuntu-latest
    if: always() && !cancelled() && needs.deploy-app.result == 'success'

    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Cleanup old images and containers
        run: |
          ssh -i ~/.ssh/deploy_key root@${{ secrets.SERVER_HOST }} << 'ENDSSH'
            echo "=== Cleaning up unused Docker resources ==="

            # Remove old per-color mongo/redis containers (now using shared infrastructure)
            for color in blue green; do
                for old_container in "expertly-${color}-mongo-1" "expertly-${color}-app-redis-1" "expertly-develop-mongo-1"; do
                    if docker ps -a --filter "name=$old_container" -q | grep -q .; then
                        echo "Removing legacy container: $old_container"
                        docker stop "$old_container" 2>/dev/null || true
                        docker rm "$old_container" 2>/dev/null || true
                    fi
                done
            done

            docker image prune -f
            docker container prune -f

            # Show current state
            echo ""
            echo "=== Current deployment state ==="
            cat /opt/deployment-state.json | jq .

            echo ""
            echo "=== Running containers ==="
            docker ps --format "table {{.Names}}\t{{.Status}}" | grep expertly || true
          ENDSSH

      - name: Final health check
        env:
          APPS_TO_CHECK: ${{ needs.detect-changes.outputs.apps_to_deploy }}
        run: |
          echo "=== Final health check ==="

          # Parse the apps to check from JSON array
          APPS=$(echo "$APPS_TO_CHECK" | jq -r '.[]' 2>/dev/null || echo "")

          if [ -z "$APPS" ]; then
            echo "No apps to check"
            exit 0
          fi

          for app in $APPS; do
            status=$(curl -s -o /dev/null -w "%{http_code}" "https://${app}.ai.devintensive.com/" || echo "000")
            if [ "$status" = "200" ]; then
              echo "✓ $app: HTTP $status"
            else
              echo "✗ $app: HTTP $status"
            fi
          done

      - name: Verify deployed versions
        env:
          APPS_TO_CHECK: ${{ needs.detect-changes.outputs.apps_to_deploy }}
          EXPECTED_COMMIT: ${{ github.sha }}
        run: |
          echo "=== Verifying deployed versions match commit ${EXPECTED_COMMIT:0:7} ==="

          # Parse the apps to check from JSON array
          APPS=$(echo "$APPS_TO_CHECK" | jq -r '.[]' 2>/dev/null || echo "")

          if [ -z "$APPS" ]; then
            echo "No apps to verify"
            exit 0
          fi

          FAILED=0
          for app in $APPS; do
            # Try to fetch version.json (not all apps have it yet)
            VERSION_JSON=$(curl -s "https://${app}.ai.devintensive.com/version.json" 2>/dev/null || echo "{}")
            DEPLOYED_VERSION=$(echo "$VERSION_JSON" | jq -r '.version // "unknown"' 2>/dev/null || echo "unknown")

            if [ "$DEPLOYED_VERSION" = "unknown" ] || [ "$DEPLOYED_VERSION" = "null" ]; then
              echo "⚠ $app: No version.json (skipping verification)"
            elif [ "$DEPLOYED_VERSION" = "${EXPECTED_COMMIT:0:7}" ]; then
              echo "✓ $app: Version matches ($DEPLOYED_VERSION)"
            else
              echo "✗ $app: Version mismatch! Expected ${EXPECTED_COMMIT:0:7}, got $DEPLOYED_VERSION"
              echo "  This may indicate Docker layer caching prevented the new code from being deployed."
              echo "  Consider rebuilding with --no-cache: docker compose build --no-cache $app-frontend"
              FAILED=1
            fi
          done

          if [ "$FAILED" = "1" ]; then
            echo ""
            echo "⚠ WARNING: Some apps have version mismatches. The deployment may not include the latest code."
            # Don't fail the build, just warn - version.json is being rolled out gradually
          fi
