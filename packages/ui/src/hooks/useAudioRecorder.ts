import { useState, useRef, useCallback } from 'react'
import type { UseAudioRecorderReturn, UseAudioRecorderOptions, VoiceTranscriptionError } from '../components/VoiceTranscription/types'
export function useAudioRecorder(opts: UseAudioRecorderOptions): UseAudioRecorderReturn {
  const { onAudioData, chunkInterval = 250 } = opts; const [isRecording, setIsRecording] = useState(false); const [error, setError] = useState<VoiceTranscriptionError | null>(null); const mrRef = useRef<MediaRecorder | null>(null); const stRef = useRef<MediaStream | null>(null)
  const startRecording = useCallback(async () => { setError(null); if (!navigator.mediaDevices?.getUserMedia) { setError({ code: 'browser_unsupported', message: 'Browser unsupported' }); return } try { const st = await navigator.mediaDevices.getUserMedia({ audio: { channelCount: 1, sampleRate: 16000, echoCancellation: true, noiseSuppression: true } }); stRef.current = st; const mt = getMime(); if (!mt) { setError({ code: 'browser_unsupported', message: 'No audio format' }); return } const mr = new MediaRecorder(st, { mimeType: mt }); mrRef.current = mr; mr.ondataavailable = (e) => { if (e.data.size > 0) onAudioData(e.data) }; mr.onerror = () => { setError({ code: 'unknown', message: 'Recording error' }); stopRecording() }; mr.onstop = () => setIsRecording(false); mr.start(chunkInterval); setIsRecording(true) } catch (e) { if (e instanceof DOMException) { if (e.name === 'NotAllowedError') { setError({ code: 'microphone_denied', message: 'Mic denied' }); return } if (e.name === 'NotFoundError') { setError({ code: 'microphone_denied', message: 'No mic' }); return } } setError({ code: 'unknown', message: 'Failed' }) } }, [onAudioData, chunkInterval])
  const stopRecording = useCallback(() => { if (mrRef.current?.state !== 'inactive') mrRef.current?.stop(); mrRef.current = null; stRef.current?.getTracks().forEach(t => t.stop()); stRef.current = null; setIsRecording(false) }, [])
  return { isRecording, startRecording, stopRecording, error }
}
function getMime(): string | null { for (const t of ['audio/webm;codecs=opus', 'audio/webm', 'audio/ogg;codecs=opus', 'audio/ogg', 'audio/mp4']) if (MediaRecorder.isTypeSupported(t)) return t; return null }
