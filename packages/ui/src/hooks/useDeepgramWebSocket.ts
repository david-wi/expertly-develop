import { useState, useRef, useCallback, useEffect } from 'react'
import type { UseDeepgramWebSocketReturn, UseDeepgramWebSocketOptions, VoiceTranscriptionError } from '../components/VoiceTranscription/types'
export function useDeepgramWebSocket(opts: UseDeepgramWebSocketOptions): UseDeepgramWebSocketReturn {
  const { url, onTranscript, onError } = opts; const [isConnected, setIsConnected] = useState(false); const [isConnecting, setIsConnecting] = useState(false); const [error, setError] = useState<VoiceTranscriptionError | null>(null); const wsRef = useRef<WebSocket | null>(null); const retries = useRef(0)
  const connect = useCallback(() => { if (wsRef.current?.readyState === WebSocket.OPEN || isConnecting) return; setError(null); setIsConnecting(true); try { const ws = new WebSocket(url); wsRef.current = ws; ws.onopen = () => { setIsConnected(true); setIsConnecting(false); retries.current = 0 }; ws.onclose = (e) => { setIsConnected(false); setIsConnecting(false); if (e.code !== 1000 && retries.current < 3) { retries.current++; setTimeout(connect, 1000 * retries.current) } else if (e.code !== 1000) { const err: VoiceTranscriptionError = { code: 'websocket_error', message: 'Lost' }; setError(err); onError?.(err) } }; ws.onerror = () => setIsConnecting(false); ws.onmessage = (e) => { try { const d = JSON.parse(e.data); if (d.type === 'transcript') onTranscript({ transcript: d.transcript || '', is_final: d.is_final || false, confidence: d.confidence, speech_final: d.speech_final }); else if (d.type === 'error') { const err: VoiceTranscriptionError = { code: 'websocket_error', message: d.message || 'Error' }; setError(err); onError?.(err) } } catch {} } } catch { setIsConnecting(false); const err: VoiceTranscriptionError = { code: 'websocket_error', message: 'Connect failed' }; setError(err); onError?.(err) } }, [url, onTranscript, onError, isConnecting])
  const disconnect = useCallback(() => { retries.current = 3; wsRef.current?.close(1000, 'User'); wsRef.current = null; setIsConnected(false); setIsConnecting(false) }, []); const sendAudio = useCallback((data: Blob) => { if (wsRef.current?.readyState === WebSocket.OPEN) wsRef.current.send(data) }, []); useEffect(() => () => { wsRef.current?.close(1000, 'Unmount') }, [])
  return { isConnected, isConnecting, connect, disconnect, sendAudio, error }
}
