import { useState, useEffect, useCallback, useRef } from 'react'
import type { UseActiveElementReturn } from '../components/VoiceTranscription/types'
export function useActiveElement(): UseActiveElementReturn {
  const [activeElement, setActiveElement] = useState<HTMLElement | null>(null)
  useEffect(() => { const h = (e: FocusEvent) => { const t = e.target as HTMLElement; if (isText(t)) setActiveElement(t) }; document.addEventListener('focusin', h); const init = document.activeElement as HTMLElement; if (isText(init)) setActiveElement(init); return () => document.removeEventListener('focusin', h) }, [])
  const injectText = useCallback((text: string) => { const el = activeElement; if (!el || !text) return; if (isIO(el)) { const i = el as HTMLInputElement | HTMLTextAreaElement, s = i.selectionStart ?? i.value.length, e = i.selectionEnd ?? i.value.length, b = i.value.substring(0, s), a = i.value.substring(e), sp = b.length > 0 && !b.endsWith(' ') && !b.endsWith('\n'), ins = sp ? ' ' + text : text; i.value = b + ins + a; i.setSelectionRange(s + ins.length, s + ins.length); i.dispatchEvent(new Event('input', { bubbles: true })) } else if (el.isContentEditable) { const sel = window.getSelection(); if (!sel || sel.rangeCount === 0) return; const r = sel.getRangeAt(0), tb = r.startContainer.textContent?.substring(0, r.startOffset) || '', sp = tb.length > 0 && !tb.endsWith(' '), ins = sp ? ' ' + text : text; r.deleteContents(); const tn = document.createTextNode(ins); r.insertNode(tn); r.setStartAfter(tn); r.setEndAfter(tn); sel.removeAllRanges(); sel.addRange(r); el.dispatchEvent(new Event('input', { bubbles: true })) } }, [activeElement])
  const replaceInterim = useCallback((old: string, newT: string) => { const el = activeElement; if (!el || !old) return; if (isIO(el)) { const i = el as HTMLInputElement | HTMLTextAreaElement, v = i.value, idx = v.lastIndexOf(old); if (idx !== -1) { i.value = v.substring(0, idx) + newT + v.substring(idx + old.length); i.setSelectionRange(idx + newT.length, idx + newT.length); i.dispatchEvent(new Event('input', { bubbles: true })) } } else if (el.isContentEditable) { const h = el.innerHTML, idx = h.lastIndexOf(old); if (idx !== -1) { el.innerHTML = h.substring(0, idx) + newT + h.substring(idx + old.length); el.dispatchEvent(new Event('input', { bubbles: true })) } } }, [activeElement])
  return { activeElement, injectText, replaceInterim }
}
function isText(el: HTMLElement | null): boolean { if (!el) return false; return isIO(el) || el.isContentEditable }
function isIO(el: HTMLElement): el is HTMLInputElement | HTMLTextAreaElement { const t = el.tagName.toLowerCase(); if (t === 'textarea') return true; if (t === 'input') { const tp = (el as HTMLInputElement).type.toLowerCase(); return ['text', 'search', 'url', 'tel', 'email', 'password', 'number'].includes(tp) } return false }
